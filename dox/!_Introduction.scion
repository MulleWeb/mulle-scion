# Give it a try

To try out these examples compile the project and put mulle-scion into your path.
It's a commandline program.

Run this example with:

   mulle-scion '!_Introduction.scion' properties.plist


# General Structure

Comments are enclosed in '{' '#' and '#' '}'

Expressions, i.e. values that produce output are enclosed in '{' '{' and '}' '}'

Commands are enclosed in '{' '%' and  '%' '}'. You can have multiple commands, 
if you separate them with semicolons. Commands do not produce output. Everything
between commends, expressions and commands is copied verbatim to the output.


# Commands

MulleScion has a small assortment of logic commands like
if else endif, for endfor, while endwhile together with various preprocessing
commands like define, block and template. Look at the documentation of each
keyword for more information


# Expressions

In a MulleScion template expressions are filled with properties from an object.
That object can be anything NSObject based. The data is accessed through 
key value coding. Anything between two curly brackets '{' is called an 
expression. The expresssion is evaluated and the resulting value is added to 
the output.

....
name={{ name }}
....

Expressions can be postprocessed with pipes.

....
when={{ name | lowercaseString }}
....

Pipes can also contain ObjC calls with parameters, where the left side of the
pipe is substituted for self in the right side.

....
when={{ name | [self stringByReplacingOccurrencesOfString:@" 1848" withString:@""] }}
....



# Key Value Coding

As that can becomen unwieldy, you can use a define to make common calls nicer to read.
....
{% define no1848 = [self stringByReplacingOccurrencesOfString:@" 1848"
                                                     withString:@""] %}
when={{ name | no1848 }}
....

You have full key value coding available. With for loops can you iterate over
collections just like NSEnumerator (it is in an NSEnumerator internally :))

....
The bag contains {{ bag.@count }} entries
{% if defined( "bag") %}
 {% for item in [bag allKeys] %}
   {{ [bag objectForKey:item] }}
 {% endfor %}
{% endif %}
...

But with dots separated by spaces you can do even more complicated KVC.


# Multiline commands

You can place multiple commands within one'{' '%' and  '%' '}'container. 
Separate the commands with semicolon or newlines. For convenience you can mix
output expressions '{' '{' '}' '}' with commands. The above example then could
be written equivalently as

....
The bag contains {{ bag.@count }} entries
{% 
  if defined( "bag")
     for item in [bag allKeys]
        {{ @"   " }} {{ [bag objectForKey:item] }} {{ @"\n" }}
     endfor
  endif 
 %}
...

Not all commands may appear in multiline commands. You can use

block/endblock
define
extends
includes
macro
requires
verbatim

only in single line commands.





